<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Discord Counting</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@2.0.2/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.0.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js"></script>
    <style>
      :root {
        --bg-color: #f0f2f5;
        --card-bg: #ffffff;
        --text-color: #333333;
        --text-muted: #6c757d;
        --accent-color: #5865f2;
        --border-color: #e0e0e0;
        --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg-color: #1e1e1e;
          --card-bg: #2c2c2c;
          --text-color: #e0e0e0;
          --text-muted: #a0a0a0;
          --border-color: #4a4a4a;
        }
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        line-height: 1.6;
      }

      .card-header {
        display: flex;
        align-items: center;
      }

      .card-title-wrapper {
        display: flex;
        align-items: center;
      }

      .card-title {
        margin-left: 10px;
      }

      .card-rank {
        font-size: 0.8rem;
        color: var(--text-muted);
        margin-left: 10px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 0;
        border-bottom: 1px solid var(--border-color);
        margin-bottom: 30px;
      }

      .server-info {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .server-icon {
        width: 50px;
        height: 50px;
        border-radius: 50%;
      }

      h1,
      h2,
      h3 {
        font-weight: 600;
      }

      .card {
        background-color: var(--card-bg);
        border-radius: 10px;
        padding: 20px;
        box-shadow: var(--shadow);
        margin-bottom: 20px;
        transition: transform 0.3s ease;
      }

      .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .card-title {
        font-size: 1.2rem;
      }

      .chart-container {
        height: 300px;
      }

      .leaderboard {
        list-style-type: none;
      }

      .leaderboard-item {
        display: flex;
        align-items: center;
        padding: 10px 0;
        border-bottom: 1px solid var(--border-color);
      }

      .leaderboard-item:last-child {
        border-bottom: none;
      }

      .leaderboard-rank {
        font-weight: 600;
        margin-right: 15px;
        color: var(--accent-color);
      }

      .leaderboard-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        margin-right: 15px;
      }

      .leaderboard-info {
        flex-grow: 1;
      }

      .leaderboard-name {
        font-weight: 600;
      }

      .leaderboard-username {
        font-size: 0.9rem;
        color: var(--text-muted);
      }

      .leaderboard-score {
        font-weight: 600;
        color: var(--accent-color);
      }

      .tabs {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
      }

      .tab {
        padding: 10px 20px;
        background-color: var(--card-bg);
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .tab:first-child {
        border-top-left-radius: 5px;
        border-bottom-left-radius: 5px;
      }

      .tab:last-child {
        border-top-right-radius: 5px;
        border-bottom-right-radius: 5px;
      }

      .tab.active {
        background-color: var(--accent-color);
        color: white;
      }

      .reset-zoom-btn {
        display: none;
        position: relative;
        float: right;
        background-color: var(--accent-color);
        color: white;
        border: 2px solid var(--text-color);
        border-radius: 8px;
        padding: 10px 15px;
        font-size: 12px;
        font-weight: bolder;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      .reset-zoom-btn:hover {
        background-color: var(--text-color);
        color: var(--card-bg);
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      .grid {
        display: grid;
        gap: 20px;
        grid-template-columns: repeat(2, 1fr);
      }

      @media (max-width: 768px) {
        .container {
          padding: 10px;
        }

        .tabs {
          flex-direction: column;
        }

        .tab {
          width: 100%;
          text-align: center;
        }
      }
    </style>
  </head>

  <body>
    <div class="container">
      <header>
        <div class="server-info">
          <img id="server-icon" class="server-icon" src="" alt="Server Icon" />
          <h1 id="server-name">Loading...</h1>
        </div>
      </header>

      <div class="tabs">
        <div class="tab active" data-tab="overview">Server</div>
        <div class="tab" data-tab="channels">Channels</div>
        <div class="tab" data-tab="users">Users</div>
        <div class="tab" data-tab="leaderboard">Leaderboard</div>
      </div>

      <div id="overview" class="tab-content active">
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">Server Overview</h2>
          </div>
          <canvas id="server-overview-chart" class="chart-container"></canvas>
        </div>
      </div>

      <div id="channels" class="tab-content">
        <div class="grid" id="channel-charts-grid"></div>
      </div>

      <div id="users" class="tab-content">
        <div class="grid" id="user-charts-grid"></div>
      </div>

      <div id="leaderboard" class="tab-content">
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">User Leaderboard</h2>
          </div>
          <ul id="leaderboard-list" class="leaderboard"></ul>
        </div>
      </div>
    </div>

    <script>
const defaultID = "1175557946474766416";

function getApiUrl() {
  const path = window.location.pathname;
  const parts = path.split("/");
  const id = parts.pop() || defaultID;
  console.log("Path:", path);
  console.log("Extracted ID:", id);

  return `https://api.communitrics.com/counting/s/${id}/all`;
}

const apiUrl = getApiUrl();
let serverData;
let charts = {};

async function fetchData() {
  try {
    const response = await fetch(apiUrl);
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error("Error fetching data:", error);
    alert("Error fetching data. Please check the console for more details.");
    return null;
  }
}

function getVibrancy(rgb) {
  const max = Math.max(rgb[0], rgb[1], rgb[2]);
  const min = Math.min(rgb[0], rgb[1], rgb[2]);
  const saturation = max - min;
  const brightness = 0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2];
  return saturation * brightness;
}

function getMostVibrantColor(palette) {
  return palette.reduce((mostVibrant, color) =>
    getVibrancy(color) > getVibrancy(mostVibrant) ? color : mostVibrant
  );
}

function extractColorFromImage(imgSrc, callback) {
  const img = new Image();
  img.crossOrigin = "Anonymous";
  img.src = imgSrc;
  img.onload = () => {
    const colorThief = new ColorThief();
    const palette = colorThief.getPalette(img, 8);
    const mostVibrantColor = getMostVibrantColor(palette);
    const color = `rgba(${mostVibrantColor.join(",")}, 0.6)`;
    callback(color);
  };
}

function initializeDashboard() {
  fetchData().then((data) => {
    if (data) {
      serverData = data;
      updateServerInfo(() => {
        createServerOverviewChart();
        createChannelCharts();
        createUserCharts();
        createLeaderboard();
        initializeTabs();
      });
    }
  });
}

function updateServerInfo(callback) {
  const serverIcon = document.getElementById("server-icon");
  const serverName = document.getElementById("server-name");
  serverName.textContent = serverData.server_name;
  serverIcon.src = serverData.server_image;

  serverIcon.onload = () => {
    extractColorFromImage(serverData.server_image, (color) => {
      document.documentElement.style.setProperty("--accent-color", color);
      callback();
    });
  };
}

function createServerOverviewChart() {
  const ctx = document
    .getElementById("server-overview-chart")
    .getContext("2d");
  const resetButton = document.createElement("button");
  resetButton.textContent = "Reset Zoom";
  resetButton.className = "reset-zoom-btn";
  const cardHeader = document.querySelector("#overview .card-header");
  cardHeader.appendChild(resetButton);

  const accentColor = getComputedStyle(
    document.documentElement
  ).getPropertyValue("--accent-color");

  resetButton.style.backgroundColor = accentColor;
  resetButton.addEventListener("mouseover", () => {
    resetButton.style.backgroundColor = "#333333";
    resetButton.style.color = "white";
  });
  resetButton.addEventListener("mouseout", () => {
    resetButton.style.backgroundColor = accentColor;
    resetButton.style.color = "white";
  });

  const allCounts = serverData.channels.flatMap((channel) =>
    channel.counts.map((count) => ({
      ...count,
      channelName: channel.channel_name,
    }))
  );

  allCounts.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

  let cumulativeCount = 0;
  const cumulativeData = allCounts.map((count) => {
    cumulativeCount += 1;
    return {
      x: luxon.DateTime.fromISO(count.timestamp).toJSDate(),
      y: cumulativeCount,
      label: count.channelName,
    };
  });

  const minDate = new Date(Math.min(...cumulativeData.map((d) => d.x)));
  const maxDate = new Date(Math.max(...cumulativeData.map((d) => d.x)));

  charts["server-overview"] = new Chart(ctx, {
    type: "line",
    data: {
      datasets: [
        {
          data: cumulativeData,
          borderColor: accentColor,
          backgroundColor: accentColor,
          fill: true,
          tension: 0.4,
        },
      ],
    },
    options: {
      responsive: true,
      animation: {
        duration: 1500,
        easing: "easeInOutQuart",
      },
      plugins: {
        legend: {
          display: false,
        },
        title: {
          display: false,
        },
        tooltip: {
          mode: "index",
          intersect: false,
        },
        zoom: {
          zoom: {
            drag: {
              enabled: true,
            },
            mode: "x",
            speed: 0.6,
            onZoomComplete: function ({ chart }) {
              resetButton.style.display = "block";
            },
            limits: {
              x: { min: minDate, max: maxDate },
            },
          },
          pan: {
            enabled: true,
            mode: "xy",
            modifierKey: "shift",
          },
        },
      },
      scales: {
        x: {
          type: "time",
          time: {
            tooltipFormat: "MMM d, yyyy, hh:mm:ss a",
            displayFormats: {
              millisecond: "MMM d, yyyy, h:mm:ss.SSS a",
              second: "MMM d, yyyy, h:mm:ss a",
              minute: "MMM d, yyyy, h:mm a",
              hour: "MMM d, yyyy, h:mm a",
              day: "MMM d, yyyy",
              week: "MMM d, yyyy",
              month: "MMM yyyy",
              quarter: "QQQ yyyy",
              year: "yyyy",
            },
          },
          ticks: {
            callback: function (value, index, values) {
              return new Intl.DateTimeFormat(navigator.language, {
                dateStyle: "short",
                timeStyle: "short",
              }).format(new Date(value));
            },
            autoSkip: true,
            maxTicksLimit: 10,
          },
        },
        y: {
          beginAtZero: true,
          title: {
            display: false,
          },
        },
      },
    },
  });

  resetButton.addEventListener("click", () => {
    charts["server-overview"].resetZoom();
    resetButton.style.display = "none";
  });
}

function createChannelCharts() {
  const channelChartsGrid = document.getElementById("channel-charts-grid");

  if (serverData.channels.length > 1) {
    channelChartsGrid.classList.add("grid");
  } else {
    channelChartsGrid.classList.remove("grid");
  }

  serverData.channels.forEach((channel) => {
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <div class="card-header">
        <h2 class="card-title">${channel.channel_name}</h2>
        <button id="resetZoomChannel-${channel.channel_id}" class="reset-zoom-btn">Reset Zoom</button>
      </div>
      <canvas id="channel-${channel.channel_id}-chart" class="chart-container"></canvas>
    `;
    channelChartsGrid.appendChild(card);

    const ctx = document
      .getElementById(`channel-${channel.channel_id}-chart`)
      .getContext("2d");
    const resetButton = document.getElementById(
      `resetZoomChannel-${channel.channel_id}`
    );

    const accentColor = getComputedStyle(
      document.documentElement
    ).getPropertyValue("--accent-color");

    resetButton.style.backgroundColor = accentColor;
    resetButton.addEventListener("mouseover", () => {
      resetButton.style.backgroundColor = "#333333";
      resetButton.style.color = "white";
    });
    resetButton.addEventListener("mouseout", () => {
      resetButton.style.backgroundColor = accentColor;
      resetButton.style.color = "white";
    });

    const allDates = channel.counts.map((count) =>
      luxon.DateTime.fromISO(count.timestamp).toJSDate()
    );
    const minDate = new Date(Math.min(...allDates));
    const maxDate = new Date(Math.max(...allDates));

    const chart = new Chart(ctx, {
      type: "line",
      data: {
        datasets: [
          {
            data: channel.counts.map((count) => ({
              x: luxon.DateTime.fromISO(count.timestamp).toJSDate(),
              y: count.count_number,
            })),
            borderColor: accentColor,
            backgroundColor: accentColor,
            fill: true,
            tension: 0.4,
          },
        ],
      },
      options: {
        responsive: true,
        animation: {
          duration: 1500,
          easing: "easeInOutQuart",
        },
        plugins: {
          legend: {
            display: false,
          },
          title: {
            display: false,
          },
          zoom: {
            zoom: {
              drag: {
                enabled: true,
              },
              mode: "x",
              speed: 0.6,
              onZoomComplete: function ({ chart }) {
                resetButton.style.display = "block";
              },
              limits: {
                x: { min: minDate, max: maxDate },
              },
            },
            pan: {
              enabled: true,
              mode: "xy",
              modifierKey: "shift",
            },
          },
        },
        scales: {
          x: {
            type: "time",
            time: {
              tooltipFormat: "MMM d, yyyy, hh:mm:ss a",
              displayFormats: {
                millisecond: "MMM d, yyyy, h:mm:ss.SSS a",
                second: "MMM d, yyyy, h:mm:ss a",
                minute: "MMM d, yyyy, h:mm a",
                hour: "MMM d, yyyy, h:mm a",
                day: "MMM d, yyyy",
                week: "MMM d, yyyy",
                month: "MMM yyyy",
                quarter: "QQQ yyyy",
                year: "yyyy",
              },
            },
            ticks: {
              callback: function (value, index, values) {
                return new Intl.DateTimeFormat(navigator.language, {
                  dateStyle: "short",
                  timeStyle: "short",
                }).format(new Date(value));
              },
              autoSkip: true,
              maxTicksLimit: 10,
            },
          },
          y: {
            beginAtZero: true,
            title: {
              display: false,
            },
          },
        },
      },
    });

    charts[`channel-${channel.channel_id}`] = chart;

    resetButton.addEventListener("click", () => {
      charts[`channel-${channel.channel_id}`].resetZoom();
      resetButton.style.display = "none";
    });
  });
}

function createUserCharts() {
  const userChartsGrid = document.getElementById("user-charts-grid");
  const userCounts = {};
  const userTotals = {};

  const allCounts = serverData.channels.flatMap((channel) =>
    channel.counts.map((count) => ({
      ...count,
      channelName: channel.channel_name,
    }))
  );

  allCounts.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

  allCounts.forEach((count) => {
    if (!userCounts[count.user_id]) {
      userCounts[count.user_id] = {
        id: count.user_id,
        username: count.username,
        display_name: count.display_name,
        profile_pic: count.profile_pic,
        counts: [],
      };
    }
    userCounts[count.user_id].counts.push({
      x: luxon.DateTime.fromISO(count.timestamp).toJSDate(),
      y: userCounts[count.user_id].counts.length + 1,
    });

    if (!userTotals[count.user_id]) {
      userTotals[count.user_id] = {
        id: count.user_id,
        total: 0,
      };
    }
    userTotals[count.user_id].total += 1;
  });

  const sortedUsers = Object.values(userTotals).sort(
    (a, b) => b.total - a.total
  );

  if (Object.keys(userCounts).length > 1) {
    userChartsGrid.classList.add("grid");
  } else {
    userChartsGrid.classList.remove("grid");
  }

  sortedUsers.forEach((userTotal, index) => {
    const user = userCounts[userTotal.id];
    const rank = index + 1;
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <div class="card-header">
          <div class="card-title-wrapper">
              <img src="${user.profile_pic}" alt="${user.display_name}'s Profile Picture" style="width: 40px; height: 40px; border-radius: 50%;">
              <div>
                  <h2 class="card-title">${user.display_name} (@${user.username})</h2>
                  <span class="card-rank">Leaderboard Rank: #${rank}</span>
              </div>
          </div>
          <button id="resetZoomUser-${user.id}" class="reset-zoom-btn">Reset Zoom</button>
      </div>
      <canvas id="user-${user.id}-chart" class="chart-container"></canvas>
    `;
    userChartsGrid.appendChild(card);

    const ctx = document
      .getElementById(`user-${user.id}-chart`)
      .getContext("2d");
    const resetButton = document.getElementById(`resetZoomUser-${user.id}`);

    const profilePic = new Image();
    profilePic.crossOrigin = "Anonymous";
    profilePic.src = user.profile_pic;
    profilePic.onload = () => {
      const colorThief = new ColorThief();
      const palette = colorThief.getPalette(profilePic, 8);
      const mostVibrantColor = getMostVibrantColor(palette);
      const color = `rgba(${mostVibrantColor.join(",")}, 0.6)`;

      resetButton.style.backgroundColor = color;
      resetButton.addEventListener("mouseover", () => {
        resetButton.style.backgroundColor = "#333333";
        resetButton.style.color = "white";
      });
      resetButton.addEventListener("mouseout", () => {
        resetButton.style.backgroundColor = color;
        resetButton.style.color = "white";
      });

      const allDates = user.counts.map((count) => count.x);
      const minDate = new Date(Math.min(...allDates));
      const maxDate = new Date(Math.max(...allDates));

      const chart = new Chart(ctx, {
        type: "line",
        data: {
          datasets: [
            {
              data: user.counts,
              borderColor: color,
              backgroundColor: color,
              fill: true,
              tension: 0.4,
            },
          ],
        },
        options: {
          responsive: true,
          animation: {
            duration: 1500,
            easing: "easeInOutQuart",
          },
          plugins: {
            legend: {
              display: false,
            },
            title: {
              display: false,
            },
            zoom: {
              zoom: {
                drag: {
                  enabled: true,
                },
                mode: "x",
                speed: 0.2,
                onZoomComplete: function ({ chart }) {
                  resetButton.style.display = "block";
                },
                limits: {
                  x: { min: minDate, max: maxDate },
                },
              },
              pan: {
                enabled: true,
                mode: "xy",
                modifierKey: "shift",
              },
            },
          },
          scales: {
            x: {
              type: "time",
              time: {
                tooltipFormat: "MMM d, yyyy, hh:mm:ss a",
                displayFormats: {
                  millisecond: "MMM d, yyyy, h:mm:ss.SSS a",
                  second: "MMM d, yyyy, h:mm:ss a",
                  minute: "MMM d, yyyy, h:mm a",
                  hour: "MMM d, yyyy, h:mm a",
                  day: "MMM d, yyyy",
                  week: "MMM d, yyyy",
                  month: "MMM yyyy",
                  quarter: "QQQ yyyy",
                  year: "yyyy",
                },
              },
              ticks: {
                callback: function (value, index, values) {
                  return new Intl.DateTimeFormat(navigator.language, {
                    dateStyle: "short",
                    timeStyle: "short",
                  }).format(new Date(value));
                },
                autoSkip: true,
                maxTicksLimit: 10,
              },
            },
            y: {
              beginAtZero: true,
              title: {
                display: false,
              },
            },
          },
        },
      });

      charts[`user-${user.id}`] = chart;

      resetButton.addEventListener("click", () => {
        charts[`user-${user.id}`].resetZoom();
        resetButton.style.display = "none";
      });
    };
  });
}

function createLeaderboard() {
  const leaderboard = document.getElementById("leaderboard-list");
  const userTotals = {};

  serverData.channels.forEach((channel) => {
    channel.counts.forEach((count) => {
      if (!userTotals[count.user_id]) {
        userTotals[count.user_id] = {
          id: count.user_id,
          username: count.username,
          display_name: count.display_name,
          profile_pic: count.profile_pic,
          total: 0,
        };
      }
      userTotals[count.user_id].total += 1;
    });
  });

  const sortedUsers = Object.values(userTotals).sort(
    (a, b) => b.total - a.total
  );

  sortedUsers.forEach((user, index) => {
    const li = document.createElement("li");
    li.className = "leaderboard-item";
    li.innerHTML = `
          <span class="leaderboard-rank">#${index + 1}</span>
          <img class="leaderboard-avatar" src="${user.profile_pic}" alt="${
            user.display_name
          }">
          <div class="leaderboard-info">
            <span class="leaderboard-name">${user.display_name}</span>
            <span class="leaderboard-username">@${user.username}</span>
          </div>
          <span class="leaderboard-score">${user.total}</span>
        `;
    leaderboard.appendChild(li);
  });
}

function initializeTabs() {
  const tabs = document.querySelectorAll(".tab");
  const tabContents = document.querySelectorAll(".tab-content");

  tabs.forEach((tab) => {
    tab.addEventListener("click", () => {
      const tabId = tab.getAttribute("data-tab");

      tabs.forEach((t) => t.classList.remove("active"));
      tabContents.forEach((content) => content.classList.remove("active"));

      tab.classList.add("active");
      document.getElementById(tabId).classList.add("active");
    });
  });
}

document.addEventListener("DOMContentLoaded", initializeDashboard);
    </script>
  </body>
</html>
